# Pytorch-minions-detection

# 1.1 样本图片预处理：

① 从网上爬取5000张图片，给图片做预处理（模式变RGB，缩放到网络需要的图像大小（我这里设置的是224）），再保存。

② 项目需求有正负样本的分类，我这里将5000个数据放到一个文件夹，前4000个样本作为训练集，4000-5000个作为测试集。

前2000的数据和4000-4500的数据，作为正样本（即图上有小黄人）；其他作为负样本。

③ 再将小黄人粘贴到图片上，由于小黄人个数比较少（20），做数据增样，方式有（缩放、旋转、随机翻转），选择粘贴位置。通过掩码去掉小黄人的背景，可以通过分割通道，用透明度的方式粘贴。

④ 做好的样本数据形式（如图）：索引+4个坐标值+置信度

![image](https://img-blog.csdnimg.cn/20200617131509119.png)

# 1.2 造数据集

① 建一个类，继承Dataset

② 重写三个方法
__init__：获取数据集路径；用列表获取每一条图片名称，是否是训练集；根据第一个索引做排序（不做排序则不是按照123456的顺序排序）。

__len__：返回数据集的长度。

__getitem(self,index)__：根据索引获得图片名称；打开图片；做转换；获取标签（标签是字符串，通过split分割点），用列表装标签（格式是坐标+置信度），坐标做一个归一化（字符串转float类型，再除以224），将坐标和置信度concatenate起来（里边是元组的格式），得到的格式为：[23,15,144,167,1]

③ 获得样本数据的均值和标准差，做的是整体5000张图片整体的。.

## 1.3 训练

__init__：设备；预处理；实例化网络；优化器；损失函数；划分训练集测试卷

tain(self)：网络存在即加载；设置轮次、批次，加载训练集；遍历训练集（放设备，数据放网络，做损失，打印迭代次数，梯度归零反向传播梯度更新）；保存网络。

# 1.4 机器学习评价指标
1）True positive(TP)： 真正例，在原始数据为正样本与预测为正样本重合的数据

2）False positive(FP): 假正例，将负样本错误预测为正样本

3）False negative(FN)：假负例，将正类错误预测为负类数；

4）True negative(TN):：真负例，将负类正确预测为负类数。

① Precision(精确率)：分类正确的正样本个数占分类器判定为正样本的样本个数的比例。

分类正确的正样本个数：即真正例(TP)。

分类器判定为正样本的个数：包括真正例(TP)和假正例(FP)。

![image](https://img-blog.csdnimg.cn/20200617165634961.png)

② Recall(召回率)：分类正确的正样本个数占真正的正样本个数的比例。

分类正确的正样本个数：即真正例(TP)。

真正的正样本个数：包括真正例(TP)和假负例(FN)

![image](https://img-blog.csdnimg.cn/20200617165741151.png)

③ F1​-score：精确率和召回率的调和均值。

![image](https://img-blog.csdnimg.cn/20200617165825581.png)

④ F score

F_1 score的通用形式，F_1 score认为precision和recall同等重要；

beta>1，Recall更重要；

beta<1，Precision更重要。

![image](https://img-blog.csdnimg.cn/20200617165926667.png)

# 1.5 测试

**test**：加载测试集；加载网络；遍历测试集（放设备）
